# This file defines an Azure DevOps pipeline that builds, tests, and Dockerizes
# an ASP.NET Framework application as a Windows container and then deploys it to Amazon ECS.

trigger:
  branches:
    include:
    - main
    - develop

resources:
  - repo: self

variables:
  - name: 'ecsClusterName'
    value: 'tipstaff_cluster'
  - name: 'ecsServiceName'
    value: 'tipstaff'
  - name: 'dockerfilePath'
    value: 'Dockerfile'
  - name: 'awsEcrRepository'
    value: '913862848426.dkr.ecr.eu-west-2.amazonaws.com/tipstaff-ecr-repo'
  - name: 'awsEcrRegion'
    value: 'eu-west-2'
  - name: 'taskDefinitionFamily'
    value: 'tipstaffFamily'
  - name: 'newDockerImage'
    value: '913862848426.dkr.ecr.eu-west-2.amazonaws.com/tipstaff-ecr-repo:latest'

stages:
- stage: BuildAndTest
  displayName: 'Build and Test Application'
  jobs:
  - job: BuildAndTest
    displayName: 'Build and Test'
    pool:
      vmImage: 'windows-2019'
    steps:
    - task: NuGetToolInstaller@1

    - task: NuGetCommand@2
      inputs:
        command: 'restore'
        restoreSolution: '**/*.sln'

    - task: VSBuild@1
      inputs:
        solution: '**/*.sln'
        configuration: 'Release'
        msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:DesktopBuildPackageLocation="$(build.artifactStagingDirectory)\WebApp.zip" /p:DeployIisAppPath="Default Web Site"'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish WebApp.zip Artifact'
      inputs:
        PathtoPublish: '$(build.artifactStagingDirectory)\WebApp.zip'
        ArtifactName: 'WebApp'
        publishLocation: 'Container'

- stage: DockerizeAndDeploy
  displayName: 'Dockerize and Deploy to AWS ECS'
  jobs:
  - job: DockerizeAndDeploy
    displayName: 'Dockerize and Deploy'
    pool:
      vmImage: 'windows-2019'
    steps:
    - task: DownloadBuildArtifacts@0
      displayName: 'Download WebApp.zip Artifact'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'WebApp'
        downloadPath: '$(Build.SourcesDirectory)'

    - task: AmazonWebServices.aws-vsts-tools.AWSShellScript.AWSShellScript@1
      displayName: 'Fetch Secrets from AWS Secrets Manager'
      inputs:
        awsCredentials: 'AWS-Tipstaff-Dev-Connection'
        regionName: 'eu-west-2'
        scriptType: 'inline'
        inlineScript: |
          # Retrieve secrets from AWS Secrets Manager
          secretsJson=$(aws secretsmanager get-secret-value --secret-id "arn:aws:secretsmanager:eu-west-2:913862848426:secret:tipstaff-dev-db-secrets-8Qc18f" --query SecretString --output text)
          
          # Decode JSON and extract secrets
          RDS_USERNAME=$(echo "$secretsJson" | jq -r '.LOCAL_DB_USERNAME')
          RDS_PASSWORD=$(echo "$secretsJson" | jq -r '.LOCAL_DB_PASSWORD')
          
          # Export secrets as environment variables
          echo "##vso[task.setvariable variable=PIPELINE_RDS_USERNAME]$RDS_USERNAME"
          echo "##vso[task.setvariable variable=PIPELINE_RDS_PASSWORD]$RDS_PASSWORD"

    - task: Docker@2
      displayName: 'Build Docker Image'
      inputs:
        command: 'build'
        Dockerfile: '$(dockerfilePath)'
        buildContext: '$(Build.SourcesDirectory)\WebApp'
        repository: $(awsEcrRepository)
        arguments: '--build-arg RDS_USERNAME=$(PIPELINE_RDS_USERNAME) --build-arg RDS_PASSWORD=$(PIPELINE_RDS_PASSWORD)'

    - script: docker images
      displayName: 'List Docker Images'

    - task: ECRPushImage@1
      displayName: 'Push image to ECR'
      inputs:
        awsCredentials: 'AWS-Tipstaff-Dev-Connection'
        regionName: $(awsEcrRegion)
        imageSource: 'imagename'
        sourceImageName: $(awsEcrRepository)
        sourceImageTag: $(Build.BuildId)
        pushTag: 'latest'
        repositoryName: 'tipstaff-ecr-repo'

    - task: AmazonWebServices.aws-vsts-tools.AWSShellScript.AWSShellScript@1
      displayName: 'Update ECS Service'
      inputs:
        awsCredentials: 'AWS-Tipstaff-Dev-Connection'
        regionName: '$(awsEcrRegion)'
        scriptType: 'inline'
        inlineScript: |
          # Retrieve the existing task definition
          EXISTING_TASK_DEFINITION=$( aws ecs describe-task-definition --task-definition $(taskDefinitionFamily) )

          # Replace the Docker image with the new one
          NEW_TASK_DEFINITION=$( echo "$EXISTING_TASK_DEFINITION" | jq --arg newImage "$(newDockerImage)" '{family: .taskDefinition.family, taskRoleArn: .taskDefinition.taskRoleArn, executionRoleArn: .taskDefinition.executionRoleArn, networkMode: .taskDefinition.networkMode, containerDefinitions: .taskDefinition.containerDefinitions, volumes: .taskDefinition.volumes, placementConstraints: .taskDefinition.placementConstraints, requiresCompatibilities: .taskDefinition.requiresCompatibilities, cpu: .taskDefinition.cpu, memory: .taskDefinition.memory, runtimePlatform: .taskDefinition.runtimePlatform} | .containerDefinitions[0].image = $newImage' )

          # Save the updated task definition to a file
          echo "$NEW_TASK_DEFINITION" > updated-task-definition.json

          # Register the updated task definition
          TASK_DEFINITION_OUTPUT=$( aws ecs register-task-definition --cli-input-json file://updated-task-definition.json )
          echo "Task Definition Output: $TASK_DEFINITION_OUTPUT"

          FAMILY_NAME=$( echo "$TASK_DEFINITION_OUTPUT" | jq -r '.taskDefinition.family' )
          echo "Family Name: $FAMILY_NAME"

          # Update the ECS service with the new task definition
          aws ecs update-service --cluster $(ecsClusterName) --service $(ecsServiceName) --task-definition $FAMILY_NAME --force-new-deployment
